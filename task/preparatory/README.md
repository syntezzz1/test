
# Подготовительный этап

Задачи:

1) Сначала запустить существующий проект. Залогиниться в веб гитлаба, настроить под себя.
2) Подключить первый раннер (в компоуз он уже есть). 
3) Прогнать задачу с кодом 
- echo ok
4) Прогнать задачу из ТЗ.

Вопросы:

1) какой существующий проект?

## Перенаправление трафика

Для того, чтобы работало через красивый `example.local`, а не IP-адрес, надо перенаправить трафик с 127.0.0.1 на локальный GitLab сервер.

- открываем hosts:

```bash
sudo nano /etc/hosts
```

- добавляем `example.local` в `hosts`:
```
127.0.0.1       example.local
```

## Запуск Docker Compose

Переходим в директорию с Docker Compose:

```bash
cd task/preparatory/
```

Запускаем Docker Compose с помощью следующей команды:

```bash
docker-compose up -d
```

Ждем пока все сервисы запустятся:

```bash
docker ps
```

## Создание раннера в интерфейсе

Авторизируемся в интерфейсе GitLab по следующему адресу, используя логин `root` и пароль из переменной `GITLAB_ROOT_PASSWORD` в `.env`:

```
http://example.local/
```

Создаем новый раннер, указывая любой удобный тег (например, `test-tag`), по следующему адресу:

```
http://example.local/admin/runners/new
```

После создания будет выдан `url` и `token`, которые должны быть использованы использованы при регистрации раннера.

## Регистрация раннера

1. Подключаемся к контейнеру, в котором будем регистрировать раннер:

```bash
docker exec -it preparatory-gitlab-runner_1 bash
```

2. Регистрируем раннер с помощью следующей команды:

```bash
gitlab-runner register \
  --url "http://example.local/" \
  --token "<your token>" 
```

В имени раннера пишем `docker-runner`. В поле `executor` пишем `docker`. В поле `docker-image` пишем `alpine:latest`.

После регистрации раннер будет отображаться как **Online** по адресу [http://example.local/admin/runners/](http://example.local/admin/runners/).

## Костыль

Поскольку раннер и сервер запускаются в разных сетевых пространствах, они не могут непосредственно общаться друг с другом, используя localhost или имена хостов, определенные внутри их собственных контейнеров. Это связано с тем, что Docker по умолчанию изолирует сетевое пространство каждого контейнера.

У нас же раннер пытается соединиться с `example.local`, но не может найти хост, т.к. этот хост мы определили только у нас (см. выше), но не в контейнере.

Нам теперь надо определить это и в контейнере, поэтому нужно зайти на раннер...:

```
docker exec -it preparatory_gitlab-runner_1 bash
```

... открыть файл конфигурации раннера ...:

```bash
vi /etc/gitlab-runner/config.toml
```

... и добавить в секцию нашего раннера (`docker-runner`) следующее:

```
network_mode = "host"
```

После этого раннер станет использовать данные из хостового `etc/hosts`.

## Первое подготовительное задание

Создаем новый проект по адресу:

```
http://example.local/projects/new
```

Переносим файл `gitlab-ci.yml` из директории  `to_gitlab_simple` в Gitlab.

Наблюдаем в логах `ok`.

## Второе подготовительное задание

### Описание задачи

Исходные данные:

ubuntu server 20.04
os:    Ubuntu 20.04.6 LTS
Docker version 24.0.5, build ced0996
компоуз запускается как docker compose (раздельно)

Виртуалка пока в 1 экземпляре.
Пока тестируемся на одной виртуалке, соотв. нужен единый докер-компоуз на гитлаб, registry, и раннер. Необходимо предусмотреть возможность задать в .env хост порт реджистри на тот случай если он будет запущен на другом сервере.

Что нужно:

Докерфайл на базе ubuntu18.04, который будет собирать проект hello_world. В докерфайле нужно установить пакеты gcc,g++, make, cmake.
gitlab-ci.yml на псевдокоде я тоже написал, он должен состоять из 2 частей - build и test.
(тест - это просто запуск артефакта из build)

Пока предлагаю упрaстить и сразу в докер-компоуз запуcтить сразу докер-файл, который будет отвечать за сборку тестового проекта. Пока докер из докера запускать не будем.

### Реализация

#### Указание хоста и порта для регистри для запуска на другом сервере

В соответствии с заданием необходимо предусмотреть возможность задать в `.env` хост порт регистри на тот случай если он будет запущен на другом сервере. В таком случае нам не нужна секция `registry-server`, так как он представляет собой локальный сервер и нужно лишь сделать так, чтобы пользовательский интерфейс мог общаться с регистри, расположенном на другом сервере.

Для этого в `.env` были добавлены следующие строки:

```
DOCKER_REGISTRY_HOST=registry-server
DOCKER_REGISTRY_PORT=5000
```

А в файле `docker-compose.yml` обновлена переменная `NGINX_PROXY_PASS_URL`:

```
      - NGINX_PROXY_PASS_URL=http://${DOCKER_REGISTRY_HOST}:${DOCKER_REGISTRY_PORT}
```

Необходимо обновить переменные `DOCKER_REGISTRY_HOST` и `DOCKER_REGISTRY_PORT` на соответствующие.

#### Подготовка образа ubuntu:custom

Переходим в директорию с Dockerfile:

```bash
cd task/preparatory/
```

Создаем образ:

```bash
docker build -t example.local:5000/ubuntu:custom .
```

Пушим образ в регистри:

```bash
docker push example.local:5000/ubuntu:custom
```

#### Тестирование

Создаем новый проект по адресу:

```
http://example.local/projects/new
```

Переносим файлы из директории `to_gitlab_hard` в Gitlab.

Наслаждаемся логами в тестовой джобе.

```bash
$ ./test_app
hello world
```






