# Как посмотреть размер образа?

Запускаем через `docker-compose up -d`, чтобы можно было пользоваться консолью (или открываем другую) и выполняем команду `docker images`. В `SIZE` будет размер образа.

# Нужно уменьшить суммарный размер образов основанных на debian, какие есть пути решения?

1. Есть слим образы, например, https://github.com/linuxcontainers/debian-slim. Этот образ весит 193MB, а тот, что в задании весит 233MB. Кстати слим образы есть только для Debian и Ubuntu, для CentOS не нашел. Видимо она и так достаточно худая.
2. Не ставить лишние пакеты. Зачем тут `nano` и `vim`?
3. Чистить ненужные пакеты и файлы после установки (мы уже так делаем `rm -rf /var/lib/apt/lists/*`)
4. Флаг `--no-install-recommends`, позволяющий не устанавливать рекомендуемые пакеты (уже так делаем, но надо быть осторожным)

Т.е. то, что сейчас указано в `RUN` уже значительно экономит место.

# Нужно уменьшить размер каждого образа, какие есть пути решения?

Тоже самое, что выше + следующее:

1. Если несколько `RUN`, то их можно объединить в один, т.к. каждый `RUN` это новый слой.
2. Если несколько `FROM`, то можно использовать мультистадийные сборки для использования одного образа для сборки, а другого для запуска и в итоге тот, который запустим будет достаточно легким.

# Чем отличаются ENV от ARG?

`ENV` задает переменные, которые сохраняются в образе и доступны во всех контейнерах, которые запускаются из образа (и следующим инструкциям в докерфайле).

`ARG` задает переменные, которые доступны только во время сборки образа плюс можно передать в аргументе `--build-arg`.

# Линтер ругается на строку ниже, хотя она работает. Что может быть не так?

Если речь идет об этом `WARNING: apt does not have a stable CLI interface. Use with caution in scripts.`, то надо вместо `apt` использовать `apt-get`, т.к. `apt-get` имеет собственный интерфейс и предназначен для использования в скриптах.

# Как перенести переменные отсюда в .env?

Создать `.env` файл с таким содержимым...:

```
APACHE_RUN_USER=www-data
APACHE_RUN_GROUP=www-data
APACHE_LOG_DIR=/var/log/apache2
APACHE_RUN_DIR=/usr/sbin/
APACHE_PID_FILE=/tmp/apache.pid
```

... и указать его в `docker-compose.yml`:

```
  upstream-debian:
    image: upstream-debian
    build:
      context: debian
    env_file:
      - .env
    hostname: upstream
    restart: unless-stopped
```

Но переменные будут доступны только во время выполнения, а не во время сборки.

# Вопрос со звёздочкой - хочу сделать единую стартовую страницу для debian и centos, как?

Создаем директорию `single_page`, которая будет содержать `index.html` со стартовой страницей и монтируем в оба upstream с помощью следующей команды:

```
volumes:
    - ./single_page:/var/www/html
```

Вольюм синхронизирует директории в контейнере и на локальной машине. 

# Хотели менять переменную порта, но что-то не сложилось. Можно поиспользовать в проекте.

```dockerfile
CMD sed -i "s/API_PORT_REPLACE/${API_PORT}/" /etc/nginx/conf.d/default.conf &&\
```

Не совсем понятно как хотели менять и что именно не сложилось. Сам по себе этот сед ничего не запустит, а в конце && прерывается. Если мы хотим заменить и запустить, то надо выполнять так: 

```dockerfile
CMD sed -i "s/API_PORT_REPLACE/${API_PORT}/" /etc/nginx/conf.d/default.conf && nginx -g 'daemon off;'
```

У меня так получилось.

Два раза выполнить CMD не получится, т.к. будет выполнена только последняя.

# Какой вариант CMD правильный и почему?

Если сравнивать `sed -i` и этот? Это два разных по смыслу CMD. Тот просто замена, а этот запускает nginx без фонового режима (FOREGROUND, т.е. занимает терминал и будет работать пока не будет остановлен). 

Докер ожидает, что процесс, который он запускает будет работать в режиме FOREGRAUND, иначе контейнер сразу остановится после запуска.

# Что это вообще такое? Как его запускать? Как его останавливать?

Это конфиг Docker Compose. Он используется для управления множеством Docker-контейнеров, которые предполагается использовать вместе.

В данном случае мы запускаем три контейнера:
- Nginx на Debian
- Apache на Debian
- Apache на CentOS

Запускаем через `docker-compose up` из директории с `docker-compose.yml`. Останавливаем и удаляем через `docker-compose down`. Можно запускать без занятия консоли через `docker-compose up -d`. Если запускаем классическим образом через `docker-compose up`, то тогда надо быть аккуратным при остановке. Если нажать `ctrl+c`, то в логах будет написано, что контейнеры остановлены, но это не тоже самое, что `docker-compose down`. В `docker-compose down` контейнеры будут удалены вместе с сетью (см. ниже про сеть). Каждый раз забываю дропнуть композ когда выхожу через `ctrl+c`.

Для каждого контейнера будут выполнены соответствующие инструкции из Dockerfile. Там указывается откуда брать образ, что туда добавить и какую основную команду(ы) выполнить в контейнере. Для каждой инструкции типа `RUN`, `COPY`, `ADD` создается свой слой. Это полезно, когда несколько образов используют один и тот же слой, а Docker хранит этот слой только один раз, а не дублирует его для каждого образа. В нашем случае, по идее, общим слоем является инструкция `RUN apt update &&\`, т.к. она выполняется и для nginx-debian и для apache-debian.

Также создается единая сеть, чтобы контейнеры могли общаться между собой по имени хоста. По умолчанию создается дефолтная, но мы можем явно указать какую сеть создавать с помощью секции `network`. Когда останавливаем композ - сеть также удаляется. Именно из-за наличия единой сети нам не нужно пробрасывать порты 80 и 8080 в centos как мы это делали в предыдущих заданиях (или отключать firewall).

# После первого запуска остановил и поменял файл default.conf, почему настройки не применились?

Потому что на момент первого запуска собирается контейнер, в который мы прокидываем дефолтный конфиг. Если остановить, поменять и запустить, то контейнер не пересоберется. Надо выполнить команду `docker-compose up --build`, чтобы он обновился.

# Можно ли собрать и запустить эти два докера без docker-compose?

Да, через `docker build -t centos .` > `docker run -d -p 80:80 centos`. Но если мы предполагаем использовать их вместе, то лучше композ.

# И вообще, почему docker-compose иногда пишут без минуса?

Без минуса пишется начиная с какой-то версии Docker Compose. Не знаю точно с какой, но знаю, что с 10 июня 2022 года)

https://9to5answer.com/how-to-view-log-output-using-docker-compose-run

Точную версию можно найти в Release Notes по дате.
 
Кстати без тире даже логично, мы ведь запускаем `docker run`, `docker build` без тире, почему тут должны.

# в чём отличие строки ниже от "image: front-nginx", "context: nginx" и "hostname: front-nginx"? Вроде везде nginx какой-то.

- `image: front-nginx` - использование образа с таким именем

- `context: nginx` - путь к директории, которая содержит Dockerfile, относительно `docker-compose.yml`

- `hostname: front-nginx` - имя хоста внутри контейнера

# Почему переменная только в левой части?

`${API_PORT}:80` означает, что порт из переменной `API_PORT` (8080) на хосте должен быть проброшен на 80 порт внутри контейнера. Кстати именно поэтому в конфиге nginx мы указываем не 8080 порт слушателя, а 80, потому что относительно контейнера мы используем 80 порт, а 8080 уже относительно локальной тачки. Когда мы запускали руками, то писали там 8080, т.к. был конфликт портов.

Кстати это отображается в `docker ps` в `PORTS`.

```bash
0.0.0.0:8080->80/tcp, :::8080->80/tcp
```

# А это зачем? Мы же переменную порта выше указали.

Вообще это определяет переменную окружения внутри контейнера и нужно для того, чтобы nginx знал какой внешний порт используется для проброса. Кажется, что в данном случае это не особо нужно. Это нужно, например, чтобы сервис генерировал какие-то выходные данные с той информацией, которую мы передали ему внутрь, например, номер порта.

# Как добавить несколько экземпляров apache на дебиан?

Через опцию `scale`:

```bash
docker-compose up --scale upstream-debian=2
```



